// Copyright 2025 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def monitor_ = MonitorRegistry.add(
	"malloc", "Tracks memory allocation and deallocation.",
	MemoryAllocationMonitor.new());

def allocfilter_ = monitor_.options.newDeclFilterOption("alloc", "filter for memory allocation functions");
def freefilter_ = monitor_.options.newDeclFilterOption("free", "filter for memory free functions");

class MemoryAllocationMonitor extends Monitor {

	var alloc_filter: DeclFilter;
	var free_filter: DeclFilter;

	def configure(args: string) -> string {
		alloc_filter = allocfilter_.val;
		free_filter = freefilter_.val;

		if (alloc_filter == null || free_filter == null) {
			def buf = StringBuilder.new();
			buf.put1("invalid argument(s) \"%s\"", args);
			return buf.toString();
		} 
		return null;
	}

	// TODO: Monitor Implementation

	def onParse(module: Module, err: ErrorGen) {
		var mm = ModuleInstrumenter.new(module);
		var alloc_func = return_func_decl_of_filter(module, alloc_filter);
		var free_func = return_func_decl_of_filter(module, free_filter);
		if (alloc_func != null) {
			mm.beforeFuncReturn(alloc_func, fire_on_alloc_return);
		} 
		global_alloc_status.module = module;
		mm.forEachFunc(instrumentFunc);
	}

	def onFinish(i: Instance, r: Result) {
		for (i : u64 = 0; i < global_alloc_status.alloc_params.length; i++) {
			if (!global_alloc_status.alloc_params.get(int.!(i)).freed) {
				output_unfreed_alloc(i + 1, global_alloc_status.alloc_params.get(int.!(i)).alloc_address);
			}
		}
	}

	private def instrumentFunc(mm: ModuleInstrumenter, func: FuncDecl) {
		current_function = func;
		def visitor = MemoryAllocationMonitorBytecodeVisitor.new(BytecodeIterator.new(), alloc_filter, free_filter, global_alloc_status.module);
		visitor.bi.reset(func).dispatchAll(visitor);
	}
}

var current_function : FuncDecl;

private class MemoryAllocationMonitorBytecodeVisitor(var bi : BytecodeIterator, alloc_filter : DeclFilter, free_filter : DeclFilter, module : Module) extends BytecodeVisitor {
	def visit_CALL(func_index: u31)	{ 
		insert(CallProbe.new(false, func_index, global_alloc_status.module, alloc_filter, free_filter));
	}
	def visit_CALL_INDIRECT(sig_index: u31, table_index: u31)	 { 
		insert(CallIndirectProbe.new(false, table_index, global_alloc_status.module, alloc_filter, free_filter));
	}
	def insert(probe: Probe) {
		Instrumentation.insertLocalProbe(global_alloc_status.module, current_function.func_index, bi.pc, probe);
	}
}

type AllocParam(freed : bool, alloc_size : u32, alloc_address : u32, callsite_pc : int, callsite_funcdecl : FuncDecl);

private class AllocStatus() {
	var module : Module;
	var curr_allocation_id : u64 = 0;
	var alloc_params = Vector<AllocParam>.new();
}

def global_alloc_status = AllocStatus.new();

def get_alloc_freed_status(id : int) -> bool {
	return global_alloc_status.alloc_params.get(id).freed;
}

def get_alloc_size(id : int) -> u32 {
	return global_alloc_status.alloc_params.get(id).alloc_size;
}

def get_alloc_address(id : int) -> u32 {
	return global_alloc_status.alloc_params.get(id).alloc_address;
}

def get_alloc_callsite_pc(id : int) -> int {
	return global_alloc_status.alloc_params.get(id).callsite_pc;
}

def get_alloc_callsite_funcdecl(id : int) -> FuncDecl{
	return global_alloc_status.alloc_params.get(id).callsite_funcdecl;
}

def is_function_specified_by_filter (module : Module, filter : DeclFilter, func_index : u31) -> bool {
	return filter.matches(module, module.functions[i32.!(func_index)]);
}

def return_func_decl_of_filter (module : Module, filter : DeclFilter) -> FuncDecl {
	for (i : u31 = 0; i < module.functions.length; i++) {
		if(is_function_specified_by_filter(module, filter, i)) {
			return module.functions[i];
		} 
		continue;
	}
	return null;
}

def fire_on_alloc_return(dynamicLoc: DynamicLoc) -> ProbeAction {
	var accessor = dynamicLoc.frame.getFrameAccessor();
	var address_value = Values.unbox_u(accessor.getTopOfStack());

	var curr_allocation_id = global_alloc_status.curr_allocation_id;
	var curr_vec_index 	   = int.!(curr_allocation_id);

	var size_of_allocation = get_alloc_size(curr_vec_index);
	var buf = StringBuilder.new().put1("Address value is %d!\n", address_value);
	buf.put1("Alloc size is %d!\n", size_of_allocation);
	System.puts(buf.toString());

	var callsite_pc = get_alloc_callsite_pc(curr_vec_index);
	var callsite_funcdecl = get_alloc_callsite_funcdecl(curr_vec_index);

	global_alloc_status.alloc_params.set(curr_vec_index, AllocParam(false, size_of_allocation, address_value, callsite_pc, callsite_funcdecl)); 

	var callcontext = CallContext(global_alloc_status.module, callsite_funcdecl, callsite_pc);
	output_alloc_record(callcontext, size_of_allocation, address_value, curr_allocation_id + 1);

	global_alloc_status.curr_allocation_id +=1;

	return ProbeAction.Continue;
}

def resolveFuncIdx(table: Table, entry_idx: int) -> int {
	if (table.funcs != null) {
		return WasmFunction.!(table.funcs[entry_idx]).decl.func_index;
	}
	return -1;
}

def update_global_alloc_status(dynamicLoc : DynamicLoc, func_index : u31, module : Module, alloc_filter : DeclFilter, free_filter : DeclFilter) -> ProbeAction {
	var accessor = dynamicLoc.frame.getFrameAccessor();
	var callsite_pc = accessor.pc();
	var callsite_funcdecl = accessor.func().decl;
	var size_of_allocation = Values.unbox_u(accessor.getTopOfStack());

	if (is_function_specified_by_filter(module, alloc_filter, func_index)) {
		var curr_allocation_id = global_alloc_status.curr_allocation_id;
		var curr_vec_index = int.!(curr_allocation_id);

		global_alloc_status.alloc_params.set(curr_vec_index, AllocParam(false, size_of_allocation, 0, callsite_pc, callsite_funcdecl)); 
		return ProbeAction.Continue;

	} else if (is_function_specified_by_filter(module, free_filter, func_index)) {
		var address_to_free = Values.unbox_u(accessor.getTopOfStack());
		var callcontext = CallContext(global_alloc_status.module, accessor.func().decl, accessor.pc());

		for (i : u64 = 0; i < global_alloc_status.alloc_params.length; i++) {
			if (get_alloc_address(int.!(i)) == address_to_free && !get_alloc_freed_status(int.!(i))) {
				output_free_record(callcontext, address_to_free, i+1);
				var new_alloc_param = AllocParam(true, get_alloc_size(int.!(i)), get_alloc_address(int.!(i)), get_alloc_callsite_pc(int.!(i)),get_alloc_callsite_funcdecl(int.!(i)));
				global_alloc_status.alloc_params.set(int.!(i), new_alloc_param);
				return ProbeAction.Continue;
			}
		} 
	
		output_free_record(callcontext, address_to_free, 0);
		return ProbeAction.Continue;

	}
	return ProbeAction.Continue;
}

private class CallProbe(tail: bool, func_index: u31, module : Module, alloc_filter : DeclFilter, free_filter : DeclFilter) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> ProbeAction {
		return update_global_alloc_status(dynamicLoc, func_index, module, alloc_filter, free_filter);
	}		
}

private class CallIndirectProbe(tail: bool, table_index: u31, module : Module, alloc_filter : DeclFilter, free_filter : DeclFilter) extends Probe { 
	def fire(dynamicLoc: DynamicLoc) -> ProbeAction {
		var accessor = dynamicLoc.frame.getFrameAccessor();
		var target_index = Values.unbox_i(accessor.getOperand(0));
		var table = dynamicLoc.func.instance.tables[table_index];
		if (table_index >= table.funcs.length) return ProbeAction.Continue; // will trap
		var func_index = resolveFuncIdx(table, target_index);

		return update_global_alloc_status(dynamicLoc, u31.!(func_index), module, alloc_filter, free_filter);
	}
}

/***** OUTPUT FORMATTING HELPER METHODS (Do not modify) *****/
/*
 * ***Output Format for Grading:***
 *
 * **Allocation Tracking Overview:**
 * Each memory allocation is tracked using a **unique, sequentially incremented id** that starts with 1.
 * This id will be used when invoking the output helper methods as specified below.
 *
 * 1. **Allocation Record Output:**
 *	- Use the helper method `output_alloc_record()` **after** the alloc function completes.
 *	- The argument passed to `output_alloc_record()` **must include the unique id** assigned to the allocation.
 *	- Ensure that the id is **sequentially incremented**, starting from **1**, for each new allocation.
 *
 * 2. **Free Record Output:**
 *	- Use the helper method `output_free_record()` **after** the free function completes.
 *	- The argument passed to `output_free_record()` **must include the id** of the respective allocation call that is being freed.
 *	- If no corresponding allocation call can be mapped, the id should be set to **0**.
 *
 * 3. **Unfreed Allocation Output:**
 *	- After the program execution completes, use the helper method `output_unfreed_alloc_record()` to print all unfreed memory allocations.
 *	- The **unfreed allocations must be printed in ascending order of their allocation id**.
 *
 * ***Important Notes:***
 * - The **correct invocation and order of output** are essential for grading.
 * - The unfreed allocations **must follow** the specified order based on their allocation id.
 * - **Do not invoke any other output functions** besides the methods specified above.
 * - **Double-check your output** to ensure it meets the required format, as incorrect output will result in lost points.
 */

type CallContext(module: Module, func: FuncDecl, pc: int);

def output_location_prefix(ctx: CallContext) {
	Trace.OUT.beginColor(Color.FUNC)
		.mark()
		.put1("<%q", ctx.func.render(ctx.module.names, _))
		.ljustify_mark(22)
		.endColors();
	Trace.OUT.beginColor(Color.FUNC)
		.putc('|');
	Trace.OUT.beginColor(Color.LINE)
		.mark()
		.put1(" +%d", ctx.pc)
		.rjustify_mark(7)
		.endColors();
	Trace.OUT.beginColor(Color.FUNC).puts(">   ").endColors();
}

// Output an allocation event
def output_alloc_record(ctx: CallContext, size: u32, addr: u32, id: u64) {
	output_location_prefix(ctx);
	def success = (addr != 0);
	// Allocation print
	Trace.OUT.beginColor(Color.SOURCE)
		.mark()
		.put1("Alloc(%d)", size)
		.rjustify_mark(14)
		.beginColor(Color.FUNC)
		.puts(" --> ");
	Trace.OUT.beginColor (if (success, Color.TYPE, Color.HIGH))
		.mark()
		.put1("%d", addr)
		.rjustify_mark(10);
	Trace.OUT.beginColor(if (success, Color.SUCCESS, Color.HIGH))
		.mark()
		.put1("[%d]", id)
		.rjustify_mark(10)
		.endColors()
		.ln();
}

// Output a free event
def output_free_record(ctx: CallContext, addr: u32, id: u64) {
	output_location_prefix(ctx);
	def success = (id != 0);
	// Free print
	Trace.OUT.beginColor(Color.COUNT)
		.mark()
		.put1("Free(%d)", addr)
		.rjustify_mark(14)
		.beginColor(Color.FUNC)
		.puts(" --> ");
	if (success) {
		Trace.OUT.beginColor(Color.SUCCESS)
			.mark()
			.put1("[%d]", id)
			.rjustify_mark(10)
			.endColors()
			.ln();
	} else {
		Trace.OUT.beginColor(Color.HIGH)
			.mark()
			.puts("[??]")
			.rjustify_mark(10)
			.endColors()
			.ln();
	}
}

// Output an unfreed allocation event
def output_unfreed_alloc(id: u64, addr: u32) {
	Trace.OUT.beginColor(Color.HIGH)
		.mark()
		.put1("[%d] ", id)
		.rjustify_mark(10);
	Trace.OUT.beginColor(Color.TYPE)
		.mark()
		.put1("%d ", addr)
		.rjustify_mark(10);
	Trace.OUT.beginColor(Color.FUNC)
		.mark()
		.puts("Unfreed Allocation")
		.ln();
}
/******************/

