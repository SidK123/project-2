// Copyright 2025 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def monitor_ = MonitorRegistry.add(
	"malloc", "Tracks memory allocation and deallocation.",
	MemoryAllocationMonitor.new());

def allocfilter_ = monitor_.options.newDeclFilterOption("alloc", "filter for memory allocation functions");
def freefilter_ = monitor_.options.newDeclFilterOption("free", "filter for memory free functions");

class MemoryAllocationMonitor extends Monitor {

	var alloc_filter: DeclFilter;
	var free_filter: DeclFilter;
	var module : Module;

	def configure(args: string) -> string {
		alloc_filter = allocfilter_.val;
		free_filter = freefilter_.val;

		if (alloc_filter == null || free_filter == null) {
			def buf = StringBuilder.new();
			buf.put1("invalid argument(s) \"%s\"", args);
			return buf.toString();
		} 
		return null;
	}

	// TODO: Monitor Implementation

	def onParse(module: Module, err: ErrorGen) {
		System.puts("In here!\n");
		var mm = ModuleInstrumenter.new(module);
		var alloc_func = return_func_decl_of_filter(module, alloc_filter);
		var free_func = return_func_decl_of_filter(module, free_filter);
		mm.beforeFuncReturn(alloc_func, fire_on_alloc_return);
		mm.beforeFuncReturn(free_func, fire_on_free_return);
		global_alloc_status.module = module;
		mm.forEachFunc(instrumentFunc);
	}

	def onFinish(i: Instance, r: Result) {
		var allocation_id : u64;
		allocation_id = 1;
		for (i = 0; i < global_alloc_status.addresses.length; i++) {
			if (!global_alloc_status.freed[i]) {
				output_unfreed_alloc(allocation_id, global_alloc_status.addresses[i]);
			}
			allocation_id += 1;
		}
	}

	private def instrumentFunc(mm: ModuleInstrumenter, func: FuncDecl) {
		current_function = func;
		def visitor = MemoryAllocationMonitorBytecodeVisitor.new(BytecodeIterator.new(), alloc_filter, free_filter, global_alloc_status.module);
		visitor.bi.reset(func).dispatchAll(visitor);
	}
}

var current_function : FuncDecl;

private class MemoryAllocationMonitorBytecodeVisitor(var bi : BytecodeIterator, alloc_filter : DeclFilter, free_filter : DeclFilter, module : Module) extends BytecodeVisitor {
	def visit_CALL(func_index: u31)	{ 
		insert(CallProbe.new(false, func_index, global_alloc_status.module, alloc_filter, free_filter));
	}
	def visit_CALL_INDIRECT(sig_index: u31, table_index: u31)	 { 
		insert(CallIndirectProbe.new(false, 0));
	}
	def visit_CALL_REF(sig_index: u31) { 
		insert(CallRefProbe.new(false, 0)); 
	}
	def insert(probe: Probe) {
		Instrumentation.insertLocalProbe(global_alloc_status.module, current_function.func_index, bi.pc, probe);
	}
}

private class AllocStatus() {
	var module : Module;
	var curr_allocation_id : u64 = 0;
	var curr_vec_index 	   : i32 = 0;
	var freed     = Vector<bool>.new();
	var size      = Vector<u32>.new();
	var addresses = Vector<u32>.new();
	var callsite_pc = Vector<int>.new();
	var callsite_funcdecl = Vector<FuncDecl>.new();
}

def global_alloc_status = AllocStatus.new();

def is_function_specified_by_filter (module : Module, filter : DeclFilter, func_index : u31) -> bool {
	return (filter.matchesStr(module.name, module.names.getFuncName(func_index)));
}

def return_func_decl_of_filter (module : Module, filter : DeclFilter) -> FuncDecl {
	for (i : u31 = 0; i < module.functions.length; i++) {
		if(is_function_specified_by_filter(module, filter, i)) {
			return module.functions[i];
		} 
		continue;
	}
	return null;
}

def fire_on_alloc_return(dynamicLoc: DynamicLoc) -> ProbeAction {
	var accessor = dynamicLoc.frame.getFrameAccessor();
	var address_value = Values.unbox_u(accessor.getTopOfStack());
	var size_of_allocation = Values.unbox_u(accessor.getLocal(0));
	var curr_allocation_id = global_alloc_status.curr_allocation_id;
	var curr_vec_index 	   = global_alloc_status.curr_vec_index;

	global_alloc_status.addresses.set(curr_vec_index, address_value); 
	global_alloc_status.freed.set(curr_vec_index, false); 
	global_alloc_status.size.set(curr_vec_index, size_of_allocation); 
	var callcontext = CallContext(global_alloc_status.module, global_alloc_status.callsite_funcdecl[curr_vec_index], global_alloc_status.callsite_pc[curr_vec_index]);
	output_alloc_record(callcontext, size_of_allocation, address_value, curr_allocation_id + 1);
	global_alloc_status.curr_allocation_id +=1;
	global_alloc_status.curr_vec_index 	   +=1;
	return ProbeAction.Continue;
}

def fire_on_free_return(dynamicLoc: DynamicLoc) -> ProbeAction {
	var accessor = dynamicLoc.frame.getFrameAccessor();
	var address_value = Values.unbox_u(accessor.getLocal(0));
	var index : u64;
	index = 1;
	for (i = 0; i < global_alloc_status.addresses.length; i++) {
		if (global_alloc_status.addresses.get(i) == address_value) {
			var callcontext = CallContext(global_alloc_status.module, global_alloc_status.callsite_funcdecl[i], global_alloc_status.callsite_pc[i]);
			if (global_alloc_status.freed.get(i)) {
				output_free_record(callcontext, address_value, 0);
			} else {
				output_free_record(callcontext, address_value, index);
			}
			global_alloc_status.freed.set(i, true);
		}
		index += 1;
	}
	return ProbeAction.Continue;
}

private class CallProbe(tail: bool, func_index: u31, module : Module, alloc_filter : DeclFilter, free_filter : DeclFilter) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> ProbeAction {
		var accessor = dynamicLoc.frame.getFrameAccessor();
		var callsite_pc = accessor.pc();
		var callsite_funcdecl = accessor.func().decl;
		if (is_function_specified_by_filter(module, alloc_filter, func_index)) {
			var curr_allocation_id = global_alloc_status.curr_allocation_id;
			var curr_vec_index = global_alloc_status.curr_vec_index;
			global_alloc_status.callsite_pc.set(curr_vec_index , callsite_pc);
			global_alloc_status.callsite_funcdecl.set(curr_vec_index, callsite_funcdecl);
			return ProbeAction.Continue;
		} else if (is_function_specified_by_filter(module, free_filter, func_index)) {
			var address_to_free = Values.unbox_u(accessor.getTopOfStack());
			for (i = 0; i < global_alloc_status.addresses.length; i++) {
				if (global_alloc_status.addresses.get(i) == address_to_free) {
					global_alloc_status.callsite_pc.set(i, callsite_pc);
					global_alloc_status.callsite_funcdecl.set(i, callsite_funcdecl);
				}
			}
			return ProbeAction.Continue;
		}
		return ProbeAction.Continue;
	}		
}

private class CallIndirectProbe(tail: bool, func_index: u31) extends Probe { 
	def fire(dynamicLoc: DynamicLoc) -> ProbeAction {
		return ProbeAction.Continue;
	}
}

private class CallRefProbe(tail: bool, func_index: u31) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> ProbeAction {
		return ProbeAction.Continue;
	}
}
/***** OUTPUT FORMATTING HELPER METHODS (Do not modify) *****/
/*
 * ***Output Format for Grading:***
 *
 * **Allocation Tracking Overview:**
 * Each memory allocation is tracked using a **unique, sequentially incremented id** that starts with 1.
 * This id will be used when invoking the output helper methods as specified below.
 *
 * 1. **Allocation Record Output:**
 *	- Use the helper method `output_alloc_record()` **after** the alloc function completes.
 *	- The argument passed to `output_alloc_record()` **must include the unique id** assigned to the allocation.
 *	- Ensure that the id is **sequentially incremented**, starting from **1**, for each new allocation.
 *
 * 2. **Free Record Output:**
 *	- Use the helper method `output_free_record()` **after** the free function completes.
 *	- The argument passed to `output_free_record()` **must include the id** of the respective allocation call that is being freed.
 *	- If no corresponding allocation call can be mapped, the id should be set to **0**.
 *
 * 3. **Unfreed Allocation Output:**
 *	- After the program execution completes, use the helper method `output_unfreed_alloc_record()` to print all unfreed memory allocations.
 *	- The **unfreed allocations must be printed in ascending order of their allocation id**.
 *
 * ***Important Notes:***
 * - The **correct invocation and order of output** are essential for grading.
 * - The unfreed allocations **must follow** the specified order based on their allocation id.
 * - **Do not invoke any other output functions** besides the methods specified above.
 * - **Double-check your output** to ensure it meets the required format, as incorrect output will result in lost points.
 */

type CallContext(module: Module, func: FuncDecl, pc: int);

def output_location_prefix(ctx: CallContext) {
	Trace.OUT.beginColor(Color.FUNC)
		.mark()
		.put1("<%q", ctx.func.render(ctx.module.names, _))
		.ljustify_mark(22)
		.endColors();
	Trace.OUT.beginColor(Color.FUNC)
		.putc('|');
	Trace.OUT.beginColor(Color.LINE)
		.mark()
		.put1(" +%d", ctx.pc)
		.rjustify_mark(7)
		.endColors();
	Trace.OUT.beginColor(Color.FUNC).puts(">   ").endColors();
}

// Output an allocation event
def output_alloc_record(ctx: CallContext, size: u32, addr: u32, id: u64) {
	output_location_prefix(ctx);
	def success = (addr != 0);
	// Allocation print
	Trace.OUT.beginColor(Color.SOURCE)
		.mark()
		.put1("Alloc(%d)", size)
		.rjustify_mark(14)
		.beginColor(Color.FUNC)
		.puts(" --> ");
	Trace.OUT.beginColor (if (success, Color.TYPE, Color.HIGH))
		.mark()
		.put1("%d", addr)
		.rjustify_mark(10);
	Trace.OUT.beginColor(if (success, Color.SUCCESS, Color.HIGH))
		.mark()
		.put1("[%d]", id)
		.rjustify_mark(10)
		.endColors()
		.ln();
}

// Output a free event
def output_free_record(ctx: CallContext, addr: u32, id: u64) {
	output_location_prefix(ctx);
	def success = (id != 0);
	// Free print
	Trace.OUT.beginColor(Color.COUNT)
		.mark()
		.put1("Free(%d)", addr)
		.rjustify_mark(14)
		.beginColor(Color.FUNC)
		.puts(" --> ");
	if (success) {
		Trace.OUT.beginColor(Color.SUCCESS)
			.mark()
			.put1("[%d]", id)
			.rjustify_mark(10)
			.endColors()
			.ln();
	} else {
		Trace.OUT.beginColor(Color.HIGH)
			.mark()
			.puts("[??]")
			.rjustify_mark(10)
			.endColors()
			.ln();
	}
}

// Output an unfreed allocation event
def output_unfreed_alloc(id: u64, addr: u32) {
	Trace.OUT.beginColor(Color.HIGH)
		.mark()
		.put1("[%d] ", id)
		.rjustify_mark(10);
	Trace.OUT.beginColor(Color.TYPE)
		.mark()
		.put1("%d ", addr)
		.rjustify_mark(10);
	Trace.OUT.beginColor(Color.FUNC)
		.mark()
		.puts("Unfreed Allocation")
		.ln();
}
/******************/

